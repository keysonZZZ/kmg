<?
package kmgRpc
func tplGenerateCode(config tplConfig) []byte {
?>
package <?=config.OutPackageName?>

import (
    <? for _,importPkg:=range config.ImportPathMap{ ?>
        "<?=importPkg?>"
    <? } ?>
)

//server
func ListenAndServe_<?=config.ObjectName?>(addr string, obj <?=config.ObjectTypeStr?>) {
	s := &generateServer_<?=config.ObjectName?>{
		obj: obj,
	}
	err := http.ListenAndServe(addr, s)
	if err != nil {
		panic(err)
	}
}

func NewServer_<?=config.ObjectName?>(obj <?=config.ObjectTypeStr?>) http.Handler {
	return &generateServer_<?=config.ObjectName?>{
		obj: obj,
	}
}

func NewClient_<?=config.ObjectName?>(RemoteUrl string) *Client_<?=config.ObjectName?> {
	return &Client_<?=config.ObjectName?>{RemoteUrl: RemoteUrl}
}

//client
// 信息服务器的客户端.
// httpjson api v1 client used for monitor to check that the server is good.
type Client_<?=config.ObjectName?> struct {
	RemoteUrl string //只有主机和地址
}


var kmgRpc_<?=config.ObjectName?>_encryptKey = kmgBase64.MustStdBase64DecodeString("<?=config.OutKeyBase64?>")

const (
	kmgRpc_<?=config.ObjectName?>_ResponseCodeSuccess byte = 1
	kmgRpc_<?=config.ObjectName?>_ResponseCodeError   byte = 2
)



type generateServer_<?=config.ObjectName?> struct {
	obj <?=config.ObjectTypeStr?>
}

// http-json-api v1
// 1.数据传输使用psk加密,明文不泄漏信息
// 2.使用json序列化信息
// 3.只有部分api
func (s *generateServer_<?=config.ObjectName?>) ServeHTTP(w http.ResponseWriter, req *http.Request) {
	b1, err := kmgHttp.RequestReadAllBody(req)
	if err != nil {
		http.Error(w, "error 1", 400)
		kmgLog.Log("InfoServerError", err.Error(), kmgHttp.NewLogStruct(req))
		return
	}

	//解密
	b1, err = kmgCrypto.AesCbcPKCS7PaddingDecrypt(b1, kmgRpc_<?=config.ObjectName?>_encryptKey)
	if err != nil {
		http.Error(w, "error 2", 400)
		kmgLog.Log("InfoServerError", err.Error(), kmgHttp.NewLogStruct(req))
		return
	}
	outBuf, err := s.handleApiV1(b1)
	if err != nil {
		kmgLog.Log("InfoServerError", err.Error(), kmgHttp.NewLogStruct(req))
		outBuf = append([]byte{kmgRpc_<?=config.ObjectName?>_ResponseCodeError}, err.Error()...)
	} else {
		outBuf = append([]byte{kmgRpc_<?=config.ObjectName?>_ResponseCodeSuccess}, outBuf...)
	}
	//加密
	outBuf = kmgCrypto.AesCbcPKCS7PaddingEncrypt(outBuf, kmgRpc_<?=config.ObjectName?>_encryptKey)
	w.WriteHeader(200)
	w.Header().Set("Content-type", "image/jpeg")
	w.Write(outBuf)
}

func (c *Client_<?=config.ObjectName?>) sendRequest(apiName string, inData interface{}, outData interface{}) (err error) {
	inDataByte, err := json.Marshal(inData)
	if err != nil {
		return
	}
	if len(apiName) > 255 {
		return errors.New("len(apiName)>255")
	}
	inByte := []byte{byte(len(apiName))}
	inByte = append(inByte, []byte(apiName)...)
	inByte = append(inByte, inDataByte...)
	inByte = kmgCrypto.AesCbcPKCS7PaddingEncrypt(inByte, kmgRpc_<?=config.ObjectName?>_encryptKey)

	resp, err := http.Post(c.RemoteUrl, "image/jpeg", bytes.NewBuffer(inByte))
	if err != nil {
		return
	}
	outByte, err := kmgHttp.ResponseReadAllBody(resp)
	if err != nil {
		return
	}
	outByte, err = kmgCrypto.AesCbcPKCS7PaddingDecrypt(outByte, kmgRpc_<?=config.ObjectName?>_encryptKey)
	if err != nil {
		return
	}
	if len(outByte) == 0 {
		return errors.New("len(outByte)==0")
	}
	switch outByte[0] {
	case kmgRpc_<?=config.ObjectName?>_ResponseCodeError:
		return errors.New(string(outByte[1:]))
	case kmgRpc_<?=config.ObjectName?>_ResponseCodeSuccess:
		return json.Unmarshal(outByte[1:], outData)
	default:
		return fmt.Errorf("httpjsonApi protocol error 1 %d", outByte[0])
	}
}



func (s *generateServer_<?=config.ObjectName?>) handleApiV1(inBuf []byte) (outBuf []byte, err error) {
	//从此处开始协议正确了,换一种返回方式
	// 1 byte api name len apiNameLen
	// apiNameLen byte api name
	// xx byte json encode of request as struct.
	if len(inBuf) < 2 {
		return nil, fmt.Errorf("len(b1)<2")
	}
	nameLength := inBuf[0]
	if len(inBuf) < int(nameLength)+1 {
		return nil, fmt.Errorf("len(b1)<nameLength+1")
	}
	name := string(inBuf[1 : int(nameLength)+1])
	b2 := inBuf[nameLength+1:]

	switch name {
	<? for _,api:=range config.ApiList{ ?>
	case "<?=api.Name?>":
	    <? for _,args:=range api.GetOutArgsListWithoutError() { ?>
	       var <?=args.Name?> <?=args.ObjectTypeStr?>
	    <? } ?>
		var err error
		reqData := &struct {
            <? for _,args:=range api.InArgsList { ?>
               <?=args.Name?> <?=args.ObjectTypeStr?>
            <? } ?>
		}{}
		err = json.Unmarshal(b2, reqData)
		if err != nil {
			return nil, err
		}
		<? if api.HasReturnArgument() { ?>
		    <?=api.GetOutArgsNameListForAssign()?> = s.obj.<?=api.Name?>(<?for _,args:=range api.InArgsList {?> reqData.<?=args.Name?>,<? } ?> )
            if err != nil {
                return nil, err
            }
		<? }else{ ?>
		    s.obj.<?=api.Name?>(<?for _,args:=range api.InArgsList {?> reqData.<?=args.Name?>,<? } ?> )
		<? } ?>
		<? if api.IsOutExpendToOneArgument() { ?>
			return json.Marshal(Response)
        <? } else { ?>
			return json.Marshal(struct {
			    <? for _,arg:=range api.GetOutArgsListWithoutError() { ?>
			        <?=arg.Name?> <?=arg.ObjectTypeStr?>
			    <? } ?>
			}{
                <? for _,arg:=range api.GetOutArgsListWithoutError() { ?>
                    <?=arg.Name?>:<?=arg.Name?>
                <? } ?>
			})
		<? } ?>
	<? } ?>
	}
	return nil, fmt.Errorf("api %s not found", name)
}

<? for _,api:=range config.ApiList { ?>
func (c *Client_<?=config.ObjectName?> ) <?=api.Name?>( <?for _,arg:=range api.InArgsList {?><?=arg.Name?> <?=arg.ObjectTypeStr?>, <? } ?>  ) (<?for _,arg:=range api.GetClientOutArgument() {?><?=arg.Name?> <?=arg.ObjectTypeStr?>, <? } ?> ) {
	reqData := &struct {
	    <?for _,arg:=range api.InArgsList {?>
	        <?=arg.Name?> <?=arg.ObjectTypeStr?>
	    <? } ?>
	}{
        <?for _,arg:=range api.InArgsList {?>
            <?=arg.Name?> <?=arg.Name?>
        <? } ?>
	}
	<? if api.IsOutExpendToOneArgument() { ?>
	    var respData <?=api.OutArgsList[0].ObjectTypeStr?>
        err = c.sendRequest("<?=api.Name?>", reqData, &respData)
        return respData,err
	<? } else { ?>
        respData := &struct {
            <? for _,arg:=range api.GetOutArgsListWithoutError() { ?>
                <?=arg.Name?> <?=arg.ObjectTypeStr?>
            <? } ?>
        }{}
        err = c.sendRequest("<?=api.Name?>", reqData, &respData)
        return <? for _,arg:=range api.GetOutArgsListWithoutError() { ?>respData.<?=arg.Name?>,<? } ?> err
    <? } ?>
}
<? } ?>
<? } ?>

